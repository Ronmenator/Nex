// Json.nex — Type-safe JSON serialization/deserialization via reflection
//
// Provides static methods to convert between [Reflectable] Nex types and JSON
// strings.  Uses the Reflect API to enumerate fields and the json_* runtime
// for robust parsing and formatting (serde_json under the hood).
//
// Requirements:
//   - Target types MUST be annotated with [Reflectable]
//   - Supported field types: String, Int, Int64, Float, Double, Bool
//   - Nested objects/arrays are not yet supported (serialized as null)
//
// Usage — Serialize:
//   [Reflectable]
//   class Person {
//       name: String
//       age: Int
//       active: Bool
//       def init(name: String, age: Int, active: Bool) -> Unit {
//           self.name = name
//           self.age = age
//           self.active = active
//           return
//       }
//   }
//
//   p = Person("Alice", 30, true)
//   json = Json.stringify("Person", p, true)
//   // {
//   //   "name": "Alice",
//   //   "age": 30,
//   //   "active": true
//   // }
//
// Usage — Deserialize:
//   Json.parse("Person", "{\"name\":\"Bob\",\"age\":25,\"active\":false}")
//   // Person fields are now populated: Person.name = "Bob", etc.
//
// Usage — Round-trip convenience:
//   json = Json.toJson("Person", p)
//   Json.fromJson("Person", json)

import std.json
import std.string

public class Json {

    // ─── Serialize ───────────────────────────────────────────────────

    // Convert a [Reflectable] object to a JSON string.
    //
    // typeName: the registered type name (e.g. "Person")
    // content:  the instance (unused in current singleton-global model,
    //           included for API forward-compatibility with per-instance fields)
    // indent:   true for pretty-printed JSON, false for compact
    //
    // Returns a JSON string, or "{}" if the type is unknown or not reflectable.
    public static def stringify(typeName: String, content: Var, indent: Bool) -> String {
        var typeId = Reflect.findType(typeName)
        if (typeId == -1) {
            return "{}"
        }
        if (Reflect.isReflectable(typeId) == 0) {
            return "{}"
        }

        // Build a serde_json object via the runtime for correct escaping
        var handle = json_new_object()
        var fieldCount = Reflect.fieldCount(typeId)
        var i = 0

        while (i < fieldCount) {
            var fname = Reflect.fieldName(typeId, i)
            var ftype = Reflect.fieldType(typeId, i)

            if (ftype == "String") {
                var val = Reflect.getFieldString(typeId, i)
                json_set_string(handle, fname, val)
            } else if (ftype == "Int" || ftype == "Int64") {
                var val = Reflect.getFieldInt(typeId, i)
                json_set_int(handle, fname, val)
            } else if (ftype == "Double" || ftype == "Float") {
                var val = Reflect.getFieldFloat(typeId, i)
                json_set_float(handle, fname, val)
            } else if (ftype == "Bool") {
                var val = Reflect.getFieldBool(typeId, i)
                if (val == 1) {
                    json_set_bool(handle, fname, 1)
                } else {
                    json_set_bool(handle, fname, 0)
                }
            } else {
                // Unknown / complex type — emit null
                json_set_null(handle, fname)
            }

            i = i + 1
        }

        // Stringify with or without indentation
        var result = ""
        if (indent) {
            result = json_stringify_pretty(handle)
        } else {
            result = json_stringify(handle)
        }

        json_free(handle)
        return result
    }

    // Convenience: stringify with pretty-printing (indented).
    public static def toJson(typeName: String, content: Var) -> String {
        return Json.stringify(typeName, content, true)
    }

    // Convenience: stringify compact (single line, no indentation).
    public static def toJsonCompact(typeName: String, content: Var) -> String {
        return Json.stringify(typeName, content, false)
    }

    // ─── Deserialize ─────────────────────────────────────────────────

    // Parse a JSON string and populate the fields of a [Reflectable] type.
    //
    // typeName: the registered type name to populate (e.g. "Person")
    // content:  the JSON string to parse
    //
    // After calling this, the type's field globals hold the parsed values.
    // In the current singleton-global model, this is equivalent to setting
    // each field directly (e.g. Person.name = "Alice").
    public static def parse(typeName: String, content: String) -> Unit {
        var typeId = Reflect.findType(typeName)
        if (typeId == -1) {
            println("Json.parse: unknown type '" + typeName + "'")
            return
        }
        if (Reflect.isReflectable(typeId) == 0) {
            println("Json.parse: type '" + typeName + "' is not [Reflectable]")
            return
        }

        var handle = json_parse(content)
        var fieldCount = Reflect.fieldCount(typeId)
        var i = 0

        while (i < fieldCount) {
            var fname = Reflect.fieldName(typeId, i)
            var ftype = Reflect.fieldType(typeId, i)

            if (ftype == "String") {
                var val = json_get_string(handle, fname)
                Reflect.setFieldString(typeId, i, val)
            } else if (ftype == "Int" || ftype == "Int64") {
                var val = json_get_int(handle, fname)
                Reflect.setFieldInt(typeId, i, val)
            } else if (ftype == "Double" || ftype == "Float") {
                var val = json_get_float(handle, fname)
                Reflect.setFieldFloat(typeId, i, val)
            } else if (ftype == "Bool") {
                var val = json_get_bool(handle, fname)
                Reflect.setFieldBool(typeId, i, val)
            }

            i = i + 1
        }

        return
    }

    // Alias for parse — reads JSON into a type's fields.
    public static def fromJson(typeName: String, content: String) -> Unit {
        Json.parse(typeName, content)
        return
    }

    // ─── Utilities ───────────────────────────────────────────────────

    // Check whether a type is registered and reflectable.
    public static def canSerialize(typeName: String) -> Bool {
        var typeId = Reflect.findType(typeName)
        if (typeId == -1) {
            return false
        }
        return Reflect.isReflectable(typeId) == 1
    }

    // Return the number of serializable fields for a type.
    public static def fieldCount(typeName: String) -> Int {
        var typeId = Reflect.findType(typeName)
        if (typeId == -1) {
            return 0
        }
        return Reflect.fieldCount(typeId)
    }
}
