<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Keywords &amp; Operators - Nex Docs</title>
  <link rel="stylesheet" href="styles.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>
<header class="site-header">
  <button class="menu-toggle">&#9776;</button>
  <div class="logo">Nex <span>Documentation</span></div>
  <div class="header-right"><span class="version-badge">v0.1.154</span></div>
</header>
<nav class="sidebar"></nav>
<main class="main-content">

  <div class="breadcrumbs"><a href="index.html">Docs</a><span class="sep">/</span>Reference<span class="sep">/</span>Keywords &amp; Operators</div>

  <h1>Keywords &amp; Operators</h1>
  <p class="page-subtitle">Complete reference of all reserved keywords, built-in types, and operators in Nex.</p>

  <h2>Reserved Keywords</h2>

  <table>
    <tr><th>Keyword</th><th>Purpose</th><th>Example</th></tr>
    <tr><td><code>def</code></td><td>Declare a function or method</td><td><code>def add(a: Int, b: Int) -> Int</code></td></tr>
    <tr><td><code>class</code></td><td>Declare a class (reference type)</td><td><code>class Animal { }</code></td></tr>
    <tr><td><code>struct</code></td><td>Declare a struct (value type)</td><td><code>struct Vec2 { x: Float }</code></td></tr>
    <tr><td><code>interface</code></td><td>Declare an interface</td><td><code>interface Printable { }</code></td></tr>
    <tr><td><code>enum</code></td><td>Declare an enumerated type</td><td><code>enum Color { Red, Green, Blue }</code></td></tr>
    <tr><td><code>public</code></td><td>Export declaration across modules</td><td><code>public def api() -> Unit</code></td></tr>
    <tr><td><code>virtual</code></td><td>Enable dynamic dispatch on method</td><td><code>virtual def area() -> Double</code></td></tr>
    <tr><td><code>override</code></td><td>Override a virtual method</td><td><code>override def area() -> Double</code></td></tr>
    <tr><td><code>static</code></td><td>Class-level (not instance) method</td><td><code>static def create() -> Unit</code></td></tr>
    <tr><td><code>shared</code></td><td>Shared base in multiple inheritance</td><td><code>class B : shared A { }</code></td></tr>
    <tr><td><code>alias</code></td><td>Alias a base class member</td><td><code>alias foo = B::foo</code></td></tr>
    <tr><td><code>import</code></td><td>Import a module</td><td><code>import std.math</code></td></tr>
    <tr><td><code>from</code></td><td>Selective import</td><td><code>from std.io import read_line</code></td></tr>
    <tr><td><code>as</code></td><td>Import alias</td><td><code>import std.math as math</code></td></tr>
    <tr><td><code>var</code></td><td>Declare dynamic variable (Var type)</td><td><code>var x = 42</code></td></tr>
    <tr><td><code>async</code></td><td>Declare an async function</td><td><code>async def fetch() -> String</code></td></tr>
    <tr><td><code>await</code></td><td>Await an async result</td><td><code>result = await fetch()</code></td></tr>
    <tr><td><code>is</code></td><td>Type check in match pattern</td><td><code>is SuccessResult as s -> s.value()</code></td></tr>
    <tr><td><code>if</code></td><td>Conditional branch / ternary</td><td><code>if (x > 0) { }</code> or <code>a if cond else b</code></td></tr>
    <tr><td><code>else</code></td><td>Alternative branch</td><td><code>else { }</code></td></tr>
    <tr><td><code>while</code></td><td>While loop</td><td><code>while (i < 10) { }</code></td></tr>
    <tr><td><code>for</code></td><td>C-style for loop</td><td><code>for (i = 0; i &lt; 10; i += 1)</code></td></tr>
    <tr><td><code>match</code></td><td>Pattern matching expression</td><td><code>match x { 1 -> "one", _ -> "other" }</code></td></tr>
    <tr><td><code>return</code></td><td>Return from function</td><td><code>return value</code></td></tr>
    <tr><td><code>break</code></td><td>Exit loop</td><td><code>break</code></td></tr>
    <tr><td><code>continue</code></td><td>Skip to next iteration</td><td><code>continue</code></td></tr>
    <tr><td><code>try</code></td><td>Exception handling block</td><td><code>try { }</code></td></tr>
    <tr><td><code>catch</code></td><td>Catch an exception</td><td><code>catch (e: Error) { }</code></td></tr>
    <tr><td><code>finally</code></td><td>Always-execute block</td><td><code>finally { }</code></td></tr>
    <tr><td><code>throw</code></td><td>Raise an exception</td><td><code>throw "error"</code></td></tr>
    <tr><td><code>using</code></td><td>Deterministic resource cleanup</td><td><code>using (f = open()) { }</code></td></tr>
    <tr><td><code>self</code></td><td>Current instance reference</td><td><code>self.name</code></td></tr>
    <tr><td><code>null</code></td><td>Null literal</td><td><code>name = null</code></td></tr>
    <tr><td><code>true</code></td><td>Boolean true</td><td><code>flag = true</code></td></tr>
    <tr><td><code>false</code></td><td>Boolean false</td><td><code>flag = false</code></td></tr>
  </table>

  <h2>Built-in Types</h2>

  <table>
    <tr><th>Type</th><th>Description</th><th>Size</th></tr>
    <tr><td><code>Bool</code></td><td>Boolean</td><td>1 byte</td></tr>
    <tr><td><code>Byte</code></td><td>Unsigned 8-bit integer (u8)</td><td>1 byte</td></tr>
    <tr><td><code>Int</code></td><td>Signed 32-bit integer (i32)</td><td>4 bytes</td></tr>
    <tr><td><code>Int64</code></td><td>Signed 64-bit integer (i64)</td><td>8 bytes</td></tr>
    <tr><td><code>Float</code></td><td>32-bit floating point (f32)</td><td>4 bytes</td></tr>
    <tr><td><code>Double</code></td><td>64-bit floating point (f64)</td><td>8 bytes</td></tr>
    <tr><td><code>Char</code></td><td>Unicode character</td><td>4 bytes</td></tr>
    <tr><td><code>String</code></td><td>Immutable string (reference type)</td><td>pointer</td></tr>
    <tr><td><code>Unit</code></td><td>Void / no value</td><td>0</td></tr>
    <tr><td><code>Var</code></td><td>Dynamic type (any value)</td><td>pointer</td></tr>
    <tr><td><code>Object</code></td><td>Universal base class</td><td>pointer</td></tr>
  </table>

  <h2>Operators</h2>

  <h3>Arithmetic</h3>
  <table>
    <tr><th>Operator</th><th>Description</th><th>Example</th></tr>
    <tr><td><code>+</code></td><td>Addition / String concatenation</td><td><code>a + b</code></td></tr>
    <tr><td><code>-</code></td><td>Subtraction</td><td><code>a - b</code></td></tr>
    <tr><td><code>*</code></td><td>Multiplication</td><td><code>a * b</code></td></tr>
    <tr><td><code>/</code></td><td>Division</td><td><code>a / b</code></td></tr>
    <tr><td><code>%</code></td><td>Modulo</td><td><code>a % b</code></td></tr>
    <tr><td><code>-</code> (unary)</td><td>Negation</td><td><code>-x</code></td></tr>
  </table>

  <h3>Comparison</h3>
  <table>
    <tr><th>Operator</th><th>Description</th></tr>
    <tr><td><code>==</code></td><td>Equal to</td></tr>
    <tr><td><code>!=</code></td><td>Not equal to</td></tr>
    <tr><td><code>&lt;</code></td><td>Less than</td></tr>
    <tr><td><code>&lt;=</code></td><td>Less than or equal</td></tr>
    <tr><td><code>&gt;</code></td><td>Greater than</td></tr>
    <tr><td><code>&gt;=</code></td><td>Greater than or equal</td></tr>
  </table>

  <h3>Logical</h3>
  <table>
    <tr><th>Operator</th><th>Description</th></tr>
    <tr><td><code>&amp;&amp;</code></td><td>Logical AND</td></tr>
    <tr><td><code>||</code></td><td>Logical OR</td></tr>
    <tr><td><code>!</code></td><td>Logical NOT (unary)</td></tr>
  </table>

  <h3>Assignment</h3>
  <table>
    <tr><th>Operator</th><th>Description</th></tr>
    <tr><td><code>=</code></td><td>Assign</td></tr>
    <tr><td><code>+=</code></td><td>Add and assign</td></tr>
    <tr><td><code>-=</code></td><td>Subtract and assign</td></tr>
    <tr><td><code>*=</code></td><td>Multiply and assign</td></tr>
    <tr><td><code>/=</code></td><td>Divide and assign</td></tr>
  </table>

  <h3>Access</h3>
  <table>
    <tr><th>Operator</th><th>Description</th><th>Example</th></tr>
    <tr><td><code>.</code></td><td>Member access</td><td><code>obj.field</code></td></tr>
    <tr><td><code>::</code></td><td>Qualified base access</td><td><code>self.Base::method()</code></td></tr>
    <tr><td><code>-&gt;</code></td><td>Return type annotation</td><td><code>def f() -> Int</code></td></tr>
  </table>

  <h3>Other Symbols</h3>
  <table>
    <tr><th>Symbol</th><th>Usage</th></tr>
    <tr><td><code>{ }</code></td><td>Block delimiters</td></tr>
    <tr><td><code>( )</code></td><td>Grouping, function calls, conditions</td></tr>
    <tr><td><code>[ ]</code></td><td>Type parameters</td></tr>
    <tr><td><code>:</code></td><td>Type annotation, base class spec</td></tr>
    <tr><td><code>,</code></td><td>Separator in lists</td></tr>
    <tr><td><code>;</code></td><td>Optional statement terminator</td></tr>
    <tr><td><code>?</code></td><td>Nullable type suffix</td></tr>
    <tr><td><code>[ ]</code></td><td>Attribute delimiters</td></tr>
    <tr><td><code>|</code></td><td>Lambda parameter delimiters</td></tr>
    <tr><td><code>$"..."</code></td><td>String interpolation</td></tr>
    <tr><td><code>Reflect</code></td><td>Built-in reflection API (<code>Reflect.findType</code>, etc.)</td></tr>
    <tr><td><code>[Reflectable]</code></td><td>Attribute to enable full reflection on a type</td></tr>
  </table>

  <div class="page-nav">
    <a href="grammar.html">
      <span class="nav-label">Previous</span>
      <span class="nav-title">&larr; Grammar (EBNF)</span>
    </a>
    <a href="runtime.html">
      <span class="nav-label">Next</span>
      <span class="nav-title">Runtime &amp; GC &rarr;</span>
    </a>
  </div>

</main>
<script src="nav.js"></script>
<script src="script.js"></script>
</body>
</html>
